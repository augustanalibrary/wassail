<?PHP
# Copyright 2009, University of Alberta
#
# This file is part of WASSAIL
#
# WASSAIL is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free 
# Software Foundation, either version 2 of the License, or (at your option) 
# any later version.

# WASSAIL is distributed in the hope that it will be useful, but WITHOUT ANY 
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
# details.

# You should have received a copy of the GNU General Public License along 
# with WASSAIL.  If not, see <http://www.gnu.org/licenses/>.


class Report
{
  private $instance_id;
  private $DB;

  private $responder_count;
  private $templates;
  private $courses;
  private $years;
  private $terms;
  private $types;

  private $conditions;
  private $error;

  function __construct()
  {
    $Account = Account::getInstance();
    $this->instance_id = $Account->instance_id;

    $this->DB = DBi::getInstance();
  }


  /*****
   * Function: setParameters
   * Purpose: To set the parameters of the report.  This is different than setting
   *          the question-based restrictions.  These parameters are used to determine
   *          which questions to allow the user to choose from.
   * Parameters: $templates: an array of template ids
   *             $courses: an array of course ids
   *             $years: an array of school year strings (ex: 2007-2008)
   *             $terms: an array of term ids
   *             $types: an array of type ids
   *
   * Note: All of these parameters must be set.  If, after the initial setting, you want
   *       to change only one of these, you still must provide all 4.  If this is the case
   *       just pull the existing parameters out of the object.
   *
   *       [First time]
   *          $Report->setParameters($templates,$courses,$years,$terms,$types)
   *       [Subsequent times]
   *          $Report->setParameters($new_templates,$Report->courses,$Report->years,$Report->terms,$Report->types);
   */
  function setParameters($templates,$courses,$years,$terms,$types)
  {
    if($this->_checkParameters($templates,$courses,$years,$terms,$types))
    {
      $this->templates = $templates;
      $this->courses = $courses;
      $this->years = $years;
      $this->terms = $terms;
      $this->types = $types;
      return TRUE;
    }
    else
      return FALSE;
  }

  private function _checkParameters(&$templates,&$courses,&$years,&$terms,&$types)
  {
    if(!is_array($templates) || count($templates) == 0)
    {
      $this->error = 'Error checking report parameters: Array of template ids was not populated.';
      return FALSE;
    }

    if(!is_array($courses) || count($courses) == 0)
    {
      $this->error = 'Error checking report parameters: Array of course ids was not populated.';
      return FALSE;
    }

    if(!is_array($years) || count($years) == 0)
    {
      $this->error = 'Error checking report parameters: Array of school years was not populated.';
      return FALSE;
    }

    if(!is_array($terms) || count($terms) == 0)
    {
      $this->error = 'Error checking report parameters: Array of term ids was not populated.';
      return FALSE;
    }

    if(!is_array($types) || count($types) == 0)
    {
      $this->error = 'Error checking report parameters: Array of type ids was not populated.';
      return FALSE;
    }

    return TRUE;
  }


  /**********
   * Function: getQuestions()
   *
   * Purpose: To retrieve the quantitative questions for a report
   * Parameters: None - checks object parameters
   * Returns: FALSE if something went wrong (or no quantitative questions exist), a list of questions if they do exist
   */
  function getQuestions()
  {
    if(!$this->_checkParameters($this->templates,$this->courses,$this->years,$this->terms,$this->types))
    {
      $this->error = 'Invalid parameters';
      return FALSE;
    }

    /* This line defines $template_clause,$course_clause,$year_clause, $term_clause,and $type_clause */
    extract($this->_generateParametersQueryClauses());


    /* the clauses generated by _generateParametersQueryClauses() don't have table names.  Since the query below has 2 tables with a 'template_id' column,
     * we need to specify which table to refer to
     */
    $template_clause = str_replace('template_id','response.template_id',$template_clause);

    /*****
     * Retrieve all responses in this instance, that aren't qualitative
     */
    $query = <<<SQL
SELECT
      distinct(response.question_id)
FROM
      response,
      question_template
WHERE
      instance_id = $this->instance_id AND
      answer_id != -1 AND
      question_template.question_id = response.question_id AND
      question_template.template_id = response.template_id AND
      $template_clause
      $course_clause
      $year_clause
      $term_clause
      $type_clause
ORDER BY
      response.question_id
SQL;

    $result = $this->DB->execute($query,'retrieving all qualifying questions');
    if(!$result)
    {
      $this->error = 'Database error while gathering qualifying questions';
      return FALSE;
    }
    else if($this->DB->numRows($result) == 0)
    {
      /* Check if there are any qualitative answers */
      if(!$this->getQualitativeData(true))
      {
    		$this->error = 'There are currently no questionnaire responses matching the selected parameters.';
    		return FALSE;
      }
      else
      {
    		$this->error = 'Only qualitative data exists for those parameters.  Check below to view the qualitative data.';
    		return FALSE;
      }
    }
    else
    {
      $ret_val = array();

      while($row = $this->DB->getData($result))
      {
    		$Question = new Question($row['question_id']);
    		$Question->loadAnswers();
    	
    		if($Question->type != 'qualitative')
    		{
    		  if($Question->answers_exist)
    		  {
      			$curr_question['text'] = $Question->text;
      			$curr_question['id'] = $row['question_id'];
      		
      			foreach($Question->answers as $Answer)
      			{
      			  $curr_question['answers'][$Answer->id] = $Answer->text;
      			}
      			$ret_val[] = $curr_question;
      			unset($curr_question);
    		  }
    		}
      }

      if(count($ret_val) == 0)
      {
    		$this->error = 'No quantitative data exists for the these parameters';
    		return FALSE;
      }

      return($ret_val);
    }
  }

  /*****
   * Function: getQualitativeData()
   * Purpose: To retrieve the qualitative data for the object parameters
   * Parameters: [boolean] $return_existence.  If TRUE, this function will return
   *                       TRUE if questions exist, FALSE if not.  This is useful if you
   *                       just want to know if the qualitative data exists, but not go through
   *                       the work of formatting & returning said data.
   */
  function getQualitativeData($return_existence=false)
  {
    if(!$this->_checkParameters($this->templates,$this->courses,$this->years,$this->terms,$this->types))
      return FALSE;

    /* This line defines $template_clause,$course_clause,$year_clause, $term_clause,and $type_clause */
    extract($this->_generateParametersQueryClauses());


	if(count($this->conditions) == 0)
 		$this->_getConditions();
		
    $responses = $this->_getApplicableResponses();
	if(!$responses)
		if($return_existence)
			return FALSE;
		else
		{
			$this->error = 'There are currently no questionnaire responses matching the selected parameters.';
		    return FALSE;
		}
	$required_clause = 'response_id IN ('.implode(',',$responses).') AND';


    /*****
     * Retrieve all responses in this instance that are qualitative
     */
    $query = <<<SQL
SELECT
      question_id,
      response_id,
      text
FROM
      response,
      response_qualitative
WHERE
		$required_clause
      instance_id = $this->instance_id AND
      answer_id = -1 AND
      $template_clause
      $course_clause
      $term_clause  
      $type_clause AND
      $year_clause
      response.id = response_qualitative.question_response_id
ORDER BY
      question_id ASC,
      response_id ASC
SQL;

    $result = $this->DB->execute($query,'retrieving all qualifying questions');
    if(!$result)
    {
      $this->error = 'Database error while gathering qualifying questions';
      return FALSE;
    }
    else if($this->DB->numRows($result) == 0)
    {
      $this->error = 'There are currently no questionnaire responses matching the selected parameters.';
      return FALSE;
    }
    else
    {
      if($return_existence)
		    return TRUE;

      $ret_val = array();

      while($row = $this->DB->getData($result))
      {
		/* Only create 1 object per question - store them after creation for re-use */
		if(!isset($Questions[$row['question_id']]))
		  $Questions[$row['question_id']] = new Question($row['question_id']);
	
		$Question = $Questions[$row['question_id']];
	
		if($Question->type == 'qualitative')
		{
		  $ret_val[$row['question_id']]['qualitative'] = TRUE;
		  $ret_val[$row['question_id']]['question_text'] = $Question->text;
		  $ret_val[$row['question_id']]['opt_out'] = $Question->opt_out;
		  $ret_val[$row['question_id']]['answers'][$row['response_id']] = $row['text'];
		}
      }
      unset($Questions);
      return($ret_val);
    }
  }   






  private function _generateParametersQueryClauses()
  {
    /* Make the template id clause */
    /* If 0 is present, 'Any' was selected, so we don't restrict on template id */
    $template_clause = '';
    if(in_array(0,$this->templates))
      $template_clause = '';
    else
    {
      foreach($this->templates as $template_id)
      {
	$template_clause .= 'template_id = '.$template_id.' OR ';
      }
      $template_clause = rtrim($template_clause,' OR ');
      $template_clause = '('.$template_clause.') AND';
    }




    /* Make the course id clause */
    /* If 0 is present, 'Any' was selected, so we don't restrict on course id */
    $course_clause = '';
    if(in_array(0,$this->courses))
      $course_clause = '';
    else
    {
      foreach($this->courses as $course_id)
      {
	$course_clause .= 'course_id = '.$course_id.' OR ';
      }
      $course_clause = rtrim($course_clause,' OR ');
      $course_clause = '('.$course_clause.') AND';
    }




    /* Make the year clause */
    /* If '--All--' is present, we don't restrict on year */
    $year_clause = '';
    if(in_array('--All--',$this->years))
      $year_clause = '';
    else
    {
      foreach($this->years as $year)
      {
	$year_clause .= 'school_year = "'.$year.'" OR ';
      }
      $year_clause = rtrim($year_clause,' OR ');
      $year_clause = '('.$year_clause.') AND';
    }




    /* Make the terms clause */
    $term_clause = '';
    foreach($this->terms as $term_id)
    {
      $term_clause .= 'term = '.$term_id.' OR ';
    }
    $term_clause = rtrim($term_clause,' OR ');
    $term_clause = '('.$term_clause.') AND';




    /* Make the type clause */
    $type_clause = '';
    foreach($this->types as $type_id)
    {
      $type_clause .= 'questionnaire_type = '.$type_id.' OR ';
    }
    $type_clause = rtrim($type_clause,' OR ');
    $type_clause = '('.$type_clause.')';





    return array('template_clause'=>$template_clause,
		 'course_clause'=>$course_clause,
		 'year_clause'=>$year_clause,
		 'term_clause'=>$term_clause,
		 'type_clause'=>$type_clause);
  }


  function getData()
  {
    $this->_getConditions();
    $responses = $this->_getApplicableResponses();
    if(!$responses)
      return $responses;

    $data = $this->_calculateData($responses);

    return $data;
  }

  /*****
   * Function: getConditions()
   * Purpose: To walk through $_POST & determine which questions need to be 
   *          applied as conditions, which need to be shown, & which can be
   *          ignored.
   *
   *          Client & server-side error checking should prevent a single question
   *          from being both conditional, shown and/or ignored, but in case it broke,
   *          the order of consideration is: conditional, show, ignore.
   */
  private function _getConditions()
  {
    if(isset($_POST['questions']))
    {
      foreach($_POST['questions'] as $question_id)
      {
		if(isset($_POST['required_'.$question_id]))
		  $this->conditions['required'][$question_id] = $_POST['required_'.$question_id];
		else if(isset($_POST['show']) && in_array($question_id,$_POST['show']))
		{				
		  $this->conditions['show'][$question_id] = $question_id;
		}
		else
		  $this->conditions['ignore'][$question_id] = $question_id;
      }
    }
  }
   
  /*****
   * Function: _getApplicableResponses()
   * Purpose: To get all the response ids for applicable responses
   * Parameters: $this->conditions['required'] - an array: keys=question ids, values = arrays of required answer ids
   * Returns: An array of response ids
   *
   * Note: This function treats the required answers as OR.  So, any response that has at least one of the
   *       required answers, will be considered 'applicable'
   */
  private function _getApplicableResponses()
  {
    /* Build the clauses that restrict responses based on initial parameters */
    /* This line defines $template_clause,$course_clause,$year_clause, $term_clause, and $type_clause */
    extract($this->_generateParametersQueryClauses());

	# testing "AND" joining
	$applicable = array();
	$required_clause = '';
	if(isset($this->conditions['required']))
    {		
		# do a query for each required question, whittling down the applicable response_ids
		foreach($this->conditions['required'] as $question_id=>$answers)
		{
			//generate question & answer clause
			$answer_ids = array();
			$question_ids[] = $question_id;
			foreach($answers as $answer_id)
			{
				$answer_ids[] = $answer_id;
			}
			$required_clause = 'question_id = '.$question_id.' AND answer_id IN ('.implode(',',$answer_ids).') AND ';
			
			//generate clause from response_ids from previous iterations
			if(count($applicable))
				$required_clause .= 'response_id IN ('.implode(',',$applicable).') AND ';
		
			$required_clause = rtrim($required_clause,' AND ');
			
			//run query
			$query = "SELECT DISTINCT(`response_id`) FROM `response` WHERE $required_clause";
			$result = $this->DB->execute($query,'retrieving applicable response ids');
			if(!$result)
			{
				$this->error = 'Unable to retrieve applicable response ids due to a database error: "'.$this->DB->getError().'"';
				return FALSE;
			}
			else if($this->DB->numRows($result) == 0)
			{
				$this->error = 'No applicable responses found';
				return FALSE;
			}
			else
			{
				//trim $applicable down further
				$applicable = array();
				while($row = $this->DB->getData($result))
			  	{
					$applicable[] = $row['response_id'];
				}
			}
		}	
		//$applicable will now be an array of response ids that fit the requirements
		//it will always be populated, or the function would already be exited.
		$required_clause = 'response_id IN ('.implode(',',$applicable).') AND';
    }


    $query = <<<SQL
SELECT
      DISTINCT(response_id)
FROM
      response
WHERE
      instance_id = $this->instance_id AND
      $required_clause
      $template_clause
      $course_clause
      $year_clause
      $term_clause
      $type_clause
ORDER BY
      number ASC
SQL;

    $result = $this->DB->execute($query,'retrieving applicable response ids');
    if(!$result)
    {
      $this->error = 'Unable to retrieve applicable response ids due to a database error: "'.$this->DB->getError().'"';
      return FALSE;
    }
    else if($this->DB->numRows($result) == 0)
    {
      $this->error = 'No applicable responses found';
      return FALSE;
    }
    else
    {
      while($row = $this->DB->getData($result))
      {
		    $ret_val[] = $row['response_id'];
      }

      $this->responder_count = count($ret_val);		

      return $ret_val;
    }
  }    

  /*****
   * Function: _calculateData()
   * Purpose: To gather the final numbers for the report.  This function
   *          finds how many responses there are for each answer.
   * Parameters: $responses: an array of response ids to work on
   */
  function _calculateData($responses)
  {
    $response_id_clause = '('.implode(',',$responses).')';


    if(isset($this->conditions['show']))
      $question_id_clause = 'response.question_id in ('.implode(',',$this->conditions['show']).') AND';
    else
      $question_id_clause = '';

    $query = <<<SQL
SELECT
      question.id as question_id,
      question.text as question_text,
      answer.id as answer_id,
      answer.text as answer_text,
      answer.correct as answer_correct
FROM
      question,
      answer,
      response,
      question_template as qt
WHERE
      response.response_id in $response_id_clause AND
      qt.question_id = response.question_id AND
      qt.template_id = response.template_id AND
      $question_id_clause
      question.id = response.question_id AND
      answer.id = response.answer_id
ORDER BY
      response.question_id,
      qt.position ASC,
      response.number,
      answer.position
SQL;

    $result = $this->DB->execute($query,'retrieving reportable questions & answers');
    if(!$result)
    {
      $this->error = 'Unable to retrieve final report data due to a database error: "'.$this->DB->getError().'"';
      return FALSE;
    }
    else
    {
      /* loop through each row & record when each answer was ... answered */
	  $ret_val = array();
      while($row = $this->DB->getData($result))
      {
		$ret_val[$row['question_id']]['quantitative'] = TRUE;
		$ret_val[$row['question_id']]['answers']['occurrences'][] = '';
		$ret_val[$row['question_id']]['question_text'] = $row['question_text'];
		$ret_val[$row['question_id']]['answers'][$row['answer_id']]['text'] = $row['answer_text'];
		$ret_val[$row['question_id']]['answers'][$row['answer_id']]['occurrences'][] = '';
		$ret_val[$row['question_id']]['answers'][$row['answer_id']]['correct'] = ($row['answer_correct']) ? TRUE : FALSE;
      }

      /*****
       * Iterate through the loop again, find & add any 'no response' occurrences
       * This can't be done in the master query, because '0' is necessarily not a
       * valid answer response
       */
      foreach($ret_val as $question_id => $properties)
      {
	$query = <<<SQL
SELECT
	  id
FROM
	  response
WHERE
	  answer_id = 0 AND
	  response_id in $response_id_clause AND
	  question_id = $question_id
SQL;


	$result = $this->DB->execute($query,'retrieving counts of unanswered responses');
	if(!$result)
	{
	  $this->error = 'Unable to retrieve "unanswered" counts due to a database error: '.$this->DB->getError();
	  return FALSE;
	}
	else
	{
		
	  while($row = $this->DB->getData($result))
	  {
	    $ret_val[$question_id]['answers']['occurrences'][] = '';
	    $ret_val[$question_id]['answers'][0]['text'] = 'No response was provided';
	    $ret_val[$question_id]['answers'][0]['occurrences'][] = '';
	  }
	}
      }	  


      /******
       * Iterate through that loop again, create the aggregate values (count & %) & remove
       * the 'occurrences' elements (which was only made so aggregate values could be calculated)
       */
      foreach($ret_val as $question_id=>$properties)
      {
		$total_answers = count($properties['answers']['occurrences']);
		/* 2 unsets as we want to remove the element from the original $ret_val
		 * as well as the local copy the foreach{} makes
		 */
		unset($ret_val[$question_id]['answers']['occurrences']);
		unset($properties['answers']['occurrences']);
	
		foreach($properties['answers'] as $answer_id=>$answer)
		{
		  $curr_answer_count = count($answer['occurrences']);
		  unset($ret_val[$question_id]['answers'][$answer_id]['occurrences']);
	
		  $percentage = number_format($curr_answer_count / $total_answers * 100,0);
	
		  $ret_val[$question_id]['count'] = $total_answers;
		  $ret_val[$question_id]['answers'][$answer_id]['count'] = $curr_answer_count;
		  $ret_val[$question_id]['answers'][$answer_id]['percentage'] = $percentage;
		}
	
		/*****
		 * The query above only returns given answers.  We need to populate the return array with
		 * those answers that no one gave, so the report will be complete with ALL possible answers
		 */
		$Question = new Question($question_id);
		$Question->loadAnswers();
		foreach($Question->answers as $answer_id=>$Answer)
		{
		  if(!isset($ret_val[$question_id]['answers'][$answer_id]))
			$ret_val[$question_id]['answers'][$answer_id] = array('text'=>$Answer->text,
									  'count'=>0,
									  'percentage'=>0);
		}
		
		# reorder the answers to the order they appear in the question.  Can't use array_multisort() because it
		# renumbers numeric keys (which are significant in this case)
		$positioned_answers = $Question->answers;
		$answers_copy = $ret_val[$question_id]['answers'];
		unset($ret_val[$question_id]['answers']);
		# iterate through the answers in the proper order, and copy over the appropriate array at the appropriate iteration
		foreach($positioned_answers as $answer_id=>$Answer)
		{
			$ret_val[$question_id]['answers'][$answer_id] = $answers_copy[$answer_id];
		}
		
		# Add any "no response" answers to the end of the answer list
		if(isset($answers_copy[0]))
			$ret_val[$question_id]['answers'][0] = $answers_copy[0];
      }

      return $ret_val;
    }
  }

	/*****
	 * Function: reorderToTemplate()
	 * Purpose: To reorder a result set (qualitative or quantitative) in the question order as
	 *          they appear in the template identified by the passed ID
	 * 			Ex: If a template has questions in this order: 120,143,166,122, use that order rather
	 *			than 120,122,143,166.
	 * Parameters: $data (array): a data result set like what's returned from _calculateData.  The format
	 *                   isn't all that important, as long as it's keyed by question id
	 *             $template_id (int): A template ID
	 */
	function reorderToTemplate($data,$template_id)
	{
		$Template = new Template($template_id);
		$ordered_data = array();
		foreach($Template->questions as $position=>$Question)
		{
			//data result set may not have all the questions in a template, so
			//we only order those that exist in the result set
			if(isset($data[$Question->id]))
				$ordered_data[$Question->id] = $data[$Question->id];
		}
		return $ordered_data;
	}

  /*****
   * Function: dataAsCSV()
   * Purpose: To convert the passed $data array (as generated by this class), into
   *          a CSV
   */
  function dataAsCSV(&$data)
  {
    $ret_val = '"question id","question text","answer id","answer text","total responses","answer responses","answer percentage"'."\n";

    foreach($data as $question_id=>$question)
    {
      //pattern taken from Template Lite's 'escape' modifier
      $question_text = trim(strip_tags(preg_replace('%(?<!\\\\)"%','\\"',$question['question_text'])));
      $question_count = $question['count'];

      foreach($question['answers'] as $answer_id=>$answer)
      {
	$answer_text = strip_tags(preg_replace('%(?<!\\\\)"%','\\"',$answer['text']));
	$answer_count = $answer['count'];
	$answer_percentage = $answer['percentage'];

	$ret_val .= <<<LINE
"$question_id","$question_text","$answer_id","$answer_text","$question_count","$answer_count","$answer_percentage"\n
LINE;
      }
    }
    return $ret_val;
  }




  /*****
   * Function: hrConditions()
   * Purpose: to convert the $conditions['required'] array from ids to their text equivalents
   *          This is used by the template.
   */
  function hrConditions()
  {
    if(isset($this->conditions['required']))
    {
      foreach($this->conditions['required'] as $question_id=>$answers)
      {
	$Question = new Question($question_id);
	$hr_question['text'] = $Question->text;
	foreach($answers as $answer_id)
	{
	  $Answer = new Answer($answer_id);
	  $hr_question['answers'][] = $Answer->text;
	}
	$hr_questions[] = $hr_question;
	unset($hr_question);
      }
    }
    else
      $hr_questions = FALSE;

    return($hr_questions);
  }


  function __get($name)
  {
    return $this->{$name};
  }
}

?>